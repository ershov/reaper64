/**
  JSFX Name: Zero delay N-Order Butterworth Filter - 6dB, 12dB, ... 72dB by ERSH
  Author: ersh
  Licence: GPL
  REAPER: 6.0
  Version: 1.0.0
  About:
    Zero delay N-Order Butterworth Filter - 6dB, 12dB, ... 72dB by ERSH
  Screenshot: https://i.imgur.com/3cRcrBI.png
  Link: https://i.imgur.com/3cRcrBI.png
  Changelog:
    v1.0:
    * Initial release
*/

// (C) 2025 Yury Ershov

// NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL OR CONSEQUENTIAL DAMAGE ARISING
// OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// ENTRUST SOMEBODY ELSE WITH DOING SO.
//
// Released under GPL:
// <http://www.gnu.org/licenses/>.

//===========================================================================
desc: ERSH Butterworth Filter - Variable Order
//tags: filter
//author: ERSH

slider5:sl_type=0<0,1,1{LowPass / HighCut,HighPass / LowCut}>Filter Type
slider10:sl_note=0<-54,67,0.01>Cutoff Note, relative to A4
slider11:sl_freq=20000<20,20020,0.1>Cutoff frequency, Hz
slider15:sl_order=1<0,12,1>Filter order (0 = bypass)
slider30:sl_output=0<-12,48,0.05>Output, dB

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

//===========================================================================
@init

ext_tail_size = -1;

LOG2 = log(2);
LOG10 = log(10);
__v2db = 20/LOG10;
function v2db(v) ( log(v)*__v2db );
function db2v(db) ( exp(db/__v2db) );

// Biquad state variables for up to 12 sections (24th order)
// Each section needs: x1, x2, y1, y2 for left and right channels
x1_l = 0; x2_l = 100; y1_l = 200; y2_l = 300;
x1_r = 400; x2_r = 500; y1_r = 600; y2_r = 700;
// Coefficients for each section
a0_coeffs = 800; a1_coeffs = 900; a2_coeffs = 1000;
b1_coeffs = 1100; b2_coeffs = 1200;

max_sections = 12; // Maximum number of sections

// Variables to track slider changes
sl_type_ = -1;
sl_order_ = -1;
sl_freq_ = -1;
sl_note_ = -1;

function onSliders() (
  // Calculate Butterworth biquad coefficients for multiple sections
  // https://en.wikipedia.org/wiki/Butterworth_filter

  sl_freq_ != sl_freq ?
    //sl_note_=sl_note = 12*log((sl_freq_=sl_freq)/440)/LOG2 :
    sl_note = 12*log((sl_freq_=sl_freq)/440)/LOG2 :
  sl_note_ != sl_note ?
    //sl_freq_=sl_freq = exp((sl_note_=sl_note)/12*LOG2)*440;
    sl_freq = exp((sl_note_=sl_note)/12*LOG2)*440;

  // Calculate how many biquad sections we need
  num_sections = min(sl_order, max_sections);
  //num_sections > 2 ? num_sections &= 0xFFFFFFFE; // Ensure even number of sections

  sl_type != sl_type_ ||
  sl_order != sl_order_ ||
  sl_freq != sl_freq_ || sl_note != sl_note_ ? (
    //// Calculate how many biquad sections we need
    //num_sections = min(sl_order, max_sections);
    ////num_sections > 2 ? num_sections &= 0xFFFFFFFE; // Ensure even number of sections

    //num_sections > 0 ? (
      // Butterworth filter design using proper pole placement
      wc = 2 * $pi * min(sl_freq, srate*0.99) / srate;  // normalized frequency, limited to prevent aliasing

      // Calculate coefficients for each biquad section
      section = 0;
      loop(max_sections,  // fill in all sections, even if not used
        // For Butterworth filters: Q = 1/(2*cos((2k+1)*π/(4N))) where N is total order
        total_order = 2 * num_sections;
        k = section; // section index
        q_factor = 1 / (2 * cos((2*k + 1) * $pi / (2 * total_order)));

        // Safety clamp
        q_factor = max(min(q_factor, 100), 0.1);

        // Use Robert Bristow-Johnson's cookbook formulas
        w0 = wc;  // Use the same cutoff for all sections
        cosw0 = cos(w0);
        sinw0 = sin(w0);
        alpha = sinw0 / (2 * q_factor);

        sl_type == 0 ? (
          // Low-pass coefficients
          b0 = (1 - cosw0) / 2;
          b1 = 1 - cosw0;
          b2 = (1 - cosw0) / 2;
          a0 = 1 + alpha;
          a1 = -2 * cosw0;
          a2 = 1 - alpha;
        ) : (
          // High-pass coefficients
          b0 = (1 + cosw0) / 2;
          b1 = -(1 + cosw0);
          b2 = (1 + cosw0) / 2;
          a0 = 1 + alpha;
          a1 = -2 * cosw0;
          a2 = 1 - alpha;
        );

        // Normalize and store coefficients
        a0_coeffs[section] = b0 / a0;
        a1_coeffs[section] = b1 / a0;
        a2_coeffs[section] = b2 / a0;
        b1_coeffs[section] = a1 / a0;
        b2_coeffs[section] = a2 / a0;

        section += 1;
      );
    //);

    // Initialize sample buffers to prevent artifacts on parameter change.
    // Preserve meaningful values for lower orders.
    sl_type != sl_type_ || sl_order != sl_order_ && num_sections < max_sections ? (
      i = num_sections+1;
      loop(max_sections - num_sections,
        x1_l[i] = x2_l[i] = y1_l[i] = y2_l[i] = 0;
        x1_r[i] = x2_r[i] = y1_r[i] = y2_r[i] = 0;
        i += 1;
      );
    );
  );

  // Update trackers
  sl_type_ = sl_type;
  sl_order_ = sl_order;
  sl_freq_ = sl_freq;
  sl_note_ = sl_note;

  out_volume = db2v(sl_output);
);

//num_sections > 0 ? (
//  i=0; loop(num_sections, ( spl0f[i] = spl1f[i] = 0; i += 1; ));
//);

//onSliders(); // this is automatic

//===========================================================================
@slider

onSliders();

//===========================================================================
@sample

// Process through cascaded Butterworth biquad sections
num_sections > 0 ? (
  // Start with input samples
  in_l = spl0;
  in_r = spl1;

  // Process through each biquad section
  section = 0;
  loop(num_sections,
    // Left channel
    out_l = a0_coeffs[section] * in_l + a1_coeffs[section] * x1_l[section] + a2_coeffs[section] * x2_l[section]
            - b1_coeffs[section] * y1_l[section] - b2_coeffs[section] * y2_l[section];

    // Safety check to prevent runaway
    abs(out_l) > 10 ? out_l = sign(out_l) * 10;

    x2_l[section] = x1_l[section];
    x1_l[section] = in_l;
    y2_l[section] = y1_l[section];
    y1_l[section] = out_l;
    in_l = out_l;  // Output becomes input for next section

    // Right channel
    out_r = a0_coeffs[section] * in_r + a1_coeffs[section] * x1_r[section] + a2_coeffs[section] * x2_r[section]
            - b1_coeffs[section] * y1_r[section] - b2_coeffs[section] * y2_r[section];

    // Safety check to prevent runaway
    abs(out_r) > 10 ? out_r = sign(out_r) * 10;

    x2_r[section] = x1_r[section];
    x1_r[section] = in_r;
    y2_r[section] = y1_r[section];
    y1_r[section] = out_r;
    in_r = out_r;  // Output becomes input for next section

    section += 1;
  );

  spl0 = in_l;
  spl1 = in_r;
);

spl0 *= out_volume;
spl1 *= out_volume;

//===========================================================================
@gfx 400 200

// Setup graphics
gfx_clear = 0x001122;
gfx_r = 0.8; gfx_g = 0.9; gfx_b = 1.0; gfx_a = 1.0;

// Draw grid
// Stepped frequency grid lines
gfx_freq_lines = 1300; // Memory location for frequency array
gfx_freq_count = 0;

// 10Hz steps
gfx_freq = 20;
loop(8,
  gfx_freq_lines[gfx_freq_count] = gfx_freq;
  gfx_freq_count += 1;
  gfx_freq += 10;
);

// 100Hz steps
gfx_freq = 100;
loop(9,
  gfx_freq_lines[gfx_freq_count] = gfx_freq;
  gfx_freq_count += 1;
  gfx_freq += 100;
);

// 1000Hz steps
gfx_freq = 1000;
loop(20,
  gfx_freq_lines[gfx_freq_count] = gfx_freq;
  gfx_freq_count += 1;
  gfx_freq += 1000;
);

// Draw all frequency lines
gfx_i = 0;
loop(gfx_freq_count,
  gfx_grid_freq = gfx_freq_lines[gfx_i];
  gfx_x_pos = log(gfx_grid_freq / 20) * gfx_w / log(1000);  // Same scale as frequency response
  gfx_r = gfx_g = gfx_b = 0.3; gfx_a = 0.5;
  gfx_line(gfx_x_pos, 0, gfx_x_pos, gfx_h);
  gfx_i += 1;
);

// Linear dB grid lines
gfx_i = 0;
loop(5,
  gfx_y_pos = gfx_i * gfx_h / 4;
  gfx_r = gfx_g = gfx_b = 0.3; gfx_a = 0.5;
  gfx_line(0, gfx_y_pos, gfx_w, gfx_y_pos);
  gfx_i += 1;
);

// Calculate and draw frequency response
num_sections > 0 ? (
  gfx_r = 1.0; gfx_g = 0.8; gfx_b = 0.2; gfx_a = 1.0;

  gfx_pixel = 0;
  loop(gfx_w,
    // Convert pixel position to frequency (log scale from 20Hz to 20kHz)
    gfx_freq = 20 * exp(gfx_pixel * log(1000) / gfx_w);

    // Calculate total magnitude in dB by summing the dB response of each section
    gfx_total_mag_db = 0;

    // Calculate complex response for this frequency
    gfx_omega = 2 * $pi * gfx_freq / srate;

    // z^-1 = e^(-jω)
    gfx_z_inv_real = cos(gfx_omega);
    gfx_z_inv_imag = -sin(gfx_omega);

    // z^-2 = e^(-2jω)
    gfx_z_inv2_real = cos(2*gfx_omega);
    gfx_z_inv2_imag = -sin(2*gfx_omega);

    gfx_section = 0;
    loop(num_sections,
      // Numerator: b0 + b1*z^-1 + b2*z^-2
      gfx_num_real = a0_coeffs[gfx_section] + a1_coeffs[gfx_section] * gfx_z_inv_real + a2_coeffs[gfx_section] * gfx_z_inv2_real;
      gfx_num_imag = a1_coeffs[gfx_section] * gfx_z_inv_imag + a2_coeffs[gfx_section] * gfx_z_inv2_imag;
      gfx_num_mag_sq = gfx_num_real*gfx_num_real + gfx_num_imag*gfx_num_imag;

      // Denominator: 1 + a1*z^-1 + a2*z^-2
      gfx_den_real = 1 + b1_coeffs[gfx_section] * gfx_z_inv_real + b2_coeffs[gfx_section] * gfx_z_inv2_real;
      gfx_den_imag = b1_coeffs[gfx_section] * gfx_z_inv_imag + b2_coeffs[gfx_section] * gfx_z_inv2_imag;
      gfx_den_mag_sq = gfx_den_real*gfx_den_real + gfx_den_imag*gfx_den_imag;

      // Prevent division by zero for this section's magnitude calculation
      gfx_den_mag_sq < 0.000000000001 ? gfx_den_mag_sq = 0.000000000001;

      // Add this section's dB magnitude to the total
      gfx_total_mag_db += v2db(sqrt(gfx_num_mag_sq / gfx_den_mag_sq));

      gfx_section += 1;
    );

    // Convert total dB to pixel position (0dB at center, ±60dB range)
    gfx_y_curve = gfx_h/2 - gfx_total_mag_db * gfx_h / 120;
    gfx_y_curve = max(0, min(gfx_h, gfx_y_curve));

    // Draw line
    gfx_pixel == 0 ? gfx_x = gfx_pixel : gfx_lineto(gfx_pixel, gfx_y_curve+0.5);
    gfx_y = gfx_y_curve;

    gfx_pixel += 1;
  );
);

// Draw frequency labels
gfx_r = gfx_g = gfx_b = 0.8; gfx_a = 1.0;
gfx_x = 5; gfx_y = 5;
gfx_printf("20Hz");
gfx_x = gfx_w - 40; gfx_y = 5;
gfx_printf("20KHz");
gfx_x = log(100 / 20) * gfx_w / log(1000) - 10;
gfx_printf("100Hz");
gfx_x = log(300 / 20) * gfx_w / log(1000) - 10;
gfx_printf("300Hz");
gfx_x = log(1000 / 20) * gfx_w / log(1000) - 10;
gfx_printf("1KHz");
gfx_x = log(3000 / 20) * gfx_w / log(1000) - 10;
gfx_printf("3KHz");

// Draw cutoff frequency indicator
gfx_cutoff_x = log(sl_freq / 20) * gfx_w / log(1000);
gfx_r = 1.0; gfx_g = 0.2; gfx_b = 0.2; gfx_a = 0.8;
gfx_line(gfx_cutoff_x, 0, gfx_cutoff_x, gfx_h);

// Draw dB scale
gfx_r = gfx_g = gfx_b = 0.8; gfx_a = 1.0;
gfx_x = 5; gfx_y = gfx_h/2 - 5;
gfx_printf("0dB");
//gfx_x = 5; gfx_y = 15;
//gfx_printf("+60dB");
gfx_x = 5; gfx_y = gfx_h - 15;
gfx_printf("-60dB");

