/**
  JSFX Name: Zero delay N-Order Pole Filter - 6dB, 12dB, ... 72dB by ERSH
  Author: ersh
  Licence: GPL
  REAPER: 6.0
  Version: 1.1.0
  About:
    Zero delay N-Order Pole Filter - 6dB, 12dB, ... 72dB by ERSH
  Screenshot: https://imgur.com/a/bc4AYwp
  Link: https://imgur.com/a/bc4AYwp
  Changelog:
    v1.0:
    * Initial release
    v1.1:
    * Frequency response graph
*/

// (C) 2025 Yury Ershov

// NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL OR CONSEQUENTIAL DAMAGE ARISING
// OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// ENTRUST SOMEBODY ELSE WITH DOING SO.
//
// Released under GPL:
// <http://www.gnu.org/licenses/>.

//===========================================================================
desc: ERSH Pole Filter - Zero delay, N-Order
//tags: filter
//author: ERSH

slider4:sl_transform=0<0,2,1{Basic,Matched-Z,TPT / Bilinear}>Transform Type
slider5:sl_type=0<0,1,1{LP,HP}>Filter Type
slider10:sl_note=0<-54,67,0.01>Cutoff Note, relative to A4
slider11:sl_freq=20000<20,20020,0.1>Cutoff frequency, Hz
slider15:sl_order=1<0,12,1>Filter order
slider16:sl_slope=6<0,72,6>Slope, dB/octave
slider30:sl_output=0<-12,48,0.05>Output, dB

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

//===========================================================================
@init

ext_tail_size = -1;

LOG2 = log(2);
LOG10 = log(10);
__v2db = 20/LOG10;
function v2db(v) ( log(v)*__v2db );
function db2v(db) ( exp(db/__v2db) );

spl0f=0;
spl1f=1000;

function onSliders() (
  // https://en.wikipedia.org/wiki/Low-pass_filter#Discrete-time_realization

  sl_freq_ != sl_freq ?
    sl_note_=sl_note = 12*log((sl_freq_=sl_freq)/440)/LOG2 :
  sl_note_ != sl_note ?
    sl_freq_=sl_freq = exp((sl_note_=sl_note)/12*LOG2)*440;

  sl_order__ = sl_order_;
  sl_slope_ != sl_slope ?
    sl_order_=sl_order = (sl_slope_=sl_slope) / 6 :
  sl_order_ != sl_order ?
    sl_slope_=sl_slope = (sl_order_=sl_order) * 6;
  // for smooth slider transition
  sl_order__  == 0 ? (
    spl0f[0] = spl0_last;
    spl1f[0] = spl1_last;
    sl_order__ = 1;
  );
  while (sl_order__ < sl_order_) (
    sl_order__ += 1;
    spl0f[sl_order__] = spl0f[sl_order__-1];
    spl1f[sl_order__] = spl1f[sl_order__-1];
  );
  sl_order__ = sl_order_;

  sl_transform == 0 ? (
    // Basic version
    dt = 1/srate;
    alpha = dt / (1/2/$pi/sl_freq + dt); // RC = 1/2/$pi/sl_freq;
    alpha1 = 1 - alpha;
  ) : sl_transform == 1 ? (
    // Matched-Z transform version
    alpha1 = exp(-2 * $pi * sl_freq / srate);
    alpha = 1 - alpha1;
  ) : sl_transform == 2 ? (
    // TPT / Bilinear transform version
    g = tan($pi * sl_freq / srate);
    alpha = g / (1 + g);
  );

  out_volume = db2v(sl_output);
);

//sl_order > 0 ? (
//  i=0; loop(sl_order, ( spl0f[i] = spl1f[i] = 0; i += 1; ));
//);

//onSliders(); // this is automatic

//===========================================================================
@slider

onSliders();

//===========================================================================
@sample

sl_order > 0 ? (
  i=0; loop(sl_order, (
    sl_transform == 0 || sl_transform == 1 ? (
      spl0f[i] = spl0*alpha + spl0f[i]*alpha1;
      spl1f[i] = spl1*alpha + spl1f[i]*alpha1;
    ) : sl_transform == 2 ? ( // TPT / Bilinear
      spl0f[i] += (spl0 - spl0f[i]) * alpha;
      spl1f[i] += (spl1 - spl1f[i]) * alpha;
    );

    sl_type == 0 ? ( // LP
      spl0  = spl0f[i];
      spl1  = spl1f[i];
    ) : ( // HP
      spl0 -= spl0f[i];
      spl1 -= spl1f[i];
    );
    i += 1;
  ));
);

spl0_last = spl0;
spl1_last = spl1;

spl0 *= out_volume;
spl1 *= out_volume;

//===========================================================================
@gfx 400 200

// Setup graphics
gfx_clear = 0x001122;
gfx_r = 0.8; gfx_g = 0.9; gfx_b = 1.0; gfx_a = 1.0;

// Draw grid
// Stepped frequency grid lines
gfx_freq_lines = 1300; // Memory location for frequency array
gfx_freq_count = 0;

// 10Hz steps
gfx_freq = 20;
loop(8,
  gfx_freq_lines[gfx_freq_count] = gfx_freq;
  gfx_freq_count += 1;
  gfx_freq += 10;
);

// 100Hz steps
gfx_freq = 100;
loop(9,
  gfx_freq_lines[gfx_freq_count] = gfx_freq;
  gfx_freq_count += 1;
  gfx_freq += 100;
);

// 1000Hz steps
gfx_freq = 1000;
loop(20,
  gfx_freq_lines[gfx_freq_count] = gfx_freq;
  gfx_freq_count += 1;
  gfx_freq += 1000;
);

// Draw all frequency lines
gfx_i = 0;
loop(gfx_freq_count,
  gfx_grid_freq = gfx_freq_lines[gfx_i];
  gfx_x_pos = log(gfx_grid_freq / 20) * gfx_w / log(1000);  // Same scale as frequency response
  gfx_r = gfx_g = gfx_b = 0.3; gfx_a = 0.5;
  gfx_line(gfx_x_pos, 0, gfx_x_pos, gfx_h);
  gfx_i += 1;
);

// Linear dB grid lines
gfx_i = 0;
loop(5,
  gfx_y_pos = gfx_i * gfx_h / 4;
  gfx_r = gfx_g = gfx_b = 0.3; gfx_a = 0.5;
  gfx_line(0, gfx_y_pos, gfx_w, gfx_y_pos);
  gfx_i += 1;
);

// Calculate and draw frequency response
gfx_r = 1.0; gfx_g = 0.8; gfx_b = 0.2; gfx_a = 1.0;
sl_order > 0 ? (

  gfx_pixel = 0;
  loop(gfx_w,
    // Convert pixel position to frequency (log scale from 20Hz to 20kHz)
    gfx_freq = 20 * exp(gfx_pixel * log(1000) / gfx_w);

    // Calculate total magnitude in dB by summing the dB response of each section
    gfx_total_mag_db = 0;

    // Calculate complex response for this frequency
    gfx_omega = 2 * $pi * gfx_freq / srate;

    // z^-1 = e^(-jω)
    gfx_z_inv_real = cos(gfx_omega);
    gfx_z_inv_imag = -sin(gfx_omega);

    // For TPT, the processing is s[n] = s[n-1] + alpha * (x[n] - s[n-1]), which gives
    // H_lp(z) = alpha / (1 - (1-alpha)*z^-1). This is the same form as Basic/Matched-Z.
    // The 'alpha' is just calculated differently.
    // The HP is 1 - LP.
    // So the graph drawing logic is identical for all transform types.

    // H_lp(z) = alpha / (1 - alpha1 * z^-1) where alpha1 = 1-alpha for Basic/Matched-Z
    // For TPT, the structure is the same, but alpha1 is not pre-calculated.
    // Let's use a local alpha1 for graphics to unify the code.
    gfx_alpha1 = (sl_transform == 0 || sl_transform == 1) ? alpha1 : 1-alpha;

    // Denominator: 1 - gfx_alpha1 * z^-1
    gfx_den_real = 1 - gfx_alpha1 * gfx_z_inv_real;
    gfx_den_imag = -gfx_alpha1 * gfx_z_inv_imag;
    gfx_den_mag_sq = gfx_den_real*gfx_den_real + gfx_den_imag*gfx_den_imag;
    gfx_den_mag_sq < 0.000000000001 ? gfx_den_mag_sq = 0.000000000001;

    sl_type == 0 ? ( // LP
      // Numerator: alpha
      gfx_num_mag_sq = alpha*alpha;
      gfx_mag_sq = gfx_num_mag_sq / gfx_den_mag_sq;
    ) : ( // HP
      // H_hp(z) = 1 - H_lp(z) = (1 - gfx_alpha1*z^-1 - alpha) / (1 - gfx_alpha1*z^-1)
      // Numerator: 1 - alpha - gfx_alpha1*z^-1
      gfx_num_real = 1 - alpha - gfx_alpha1 * gfx_z_inv_real;
      gfx_num_imag = -gfx_alpha1 * gfx_z_inv_imag;
      gfx_num_mag_sq = gfx_num_real*gfx_num_real + gfx_num_imag*gfx_num_imag;
      gfx_mag_sq = gfx_num_mag_sq / gfx_den_mag_sq;
    );

    // For N-order, magnitude is mag^N, so dB is N * v2db(mag)
    gfx_total_mag_db = sl_order * v2db(sqrt(gfx_mag_sq));

    // Convert total dB to pixel position (0dB at center, ±60dB range)
    gfx_y_curve = gfx_h/2 - gfx_total_mag_db * gfx_h / 120;
    gfx_y_curve = max(0, min(gfx_h, gfx_y_curve));

    // Draw line
    gfx_pixel == 0 ? gfx_x = gfx_pixel : gfx_lineto(gfx_pixel, gfx_y_curve+0.5);
    gfx_y = gfx_y_curve;

    gfx_pixel += 1;
  );
) : (
  gfx_line(0, gfx_h/2, gfx_w, gfx_h/2);
);

// Draw cutoff frequency indicator
gfx_cutoff_x = log(sl_freq / 20) * gfx_w / log(1000);
gfx_r = 1.0; gfx_g = 0.2; gfx_b = 0.2; gfx_a = 0.8;
gfx_line(gfx_cutoff_x, 0, gfx_cutoff_x, gfx_h);

// Draw frequency labels
gfx_r = gfx_g = gfx_b = 0.8; gfx_a = 1.0;
gfx_x = 5; gfx_y = 5;
gfx_printf("20Hz");
gfx_x = gfx_w - 40; gfx_y = 5;
gfx_printf("20KHz");
gfx_x = log(100 / 20) * gfx_w / log(1000) - 10;
gfx_printf("100Hz");
gfx_x = log(300 / 20) * gfx_w / log(1000) - 10;
gfx_printf("300Hz");
gfx_x = log(1000 / 20) * gfx_w / log(1000) - 10;
gfx_printf("1KHz");
gfx_x = log(3000 / 20) * gfx_w / log(1000) - 10;
gfx_printf("3KHz");

// Draw dB scale
gfx_r = gfx_g = gfx_b = 0.8; gfx_a = 1.0;
gfx_x = 5; gfx_y = gfx_h/2 - 5;
gfx_printf("0dB");
//gfx_x = 5; gfx_y = 15;
//gfx_printf("+60dB");
gfx_x = 5; gfx_y = gfx_h - 15;
gfx_printf("-60dB");

